# Declarative Macros

There are two main types of macros in Rust:

* **Declarative Macros**. These macros are processed after the program's source code has been transformed into an AST (Abstract Syntax Tree). They manipulate AST nodes, which makes them relatively easy to write and quite safe. Essentially, declarative macros are functions that run at compile time and manipulate AST nodes rather than data.

* **Procedural Macros**. These macros take a token stream as input and produce a token stream as output. Since they operate before the lexical analysis of the program text, they allow you to literally create another language within Rust. We won't be covering procedural macros in this book, as they are complex and typical backend development rarely requires creating new ones.

## Our First Declarative Macro

Declarative macros are declared using the `#[macro_export]` annotation, followed by the macro description using a special Scheme-like syntax.

```
#[macro_export]
macro_rules! macro_name {
    ( pattern_1 ) => { expansion_1 };
    ( pattern_2 ) => { expansion_2 };
    ...
    ( pattern_N ) => { expansion_N }
}
```

To start, let's look at a simple macro that sums two numbers:

```rust
#[macro_export]
macro_rules! sum_nums { // Declare a macro named sum_nums
    ( $x:expr, $y:expr ) => { $x + $y }
}

fn main() {
    let res = sum_nums!(1, 2); // Invoke the macro
    println!("Sum is: {}", res);
}
```

During compilation, the macro call will be "expanded" into the following:

```rust
fn main() {
    let res = 1 + 2;
    println!("Sum is: {}", res);
}
```

As you can see, the compiler simply replaced the macro call with the generated Rust code and continued the compilation process.

> [!TIP]
> You can see what expressions a macro call expands into using the [cargo expand](https://crates.io/crates/cargo-expand) utility.

Now, let's break down the macro declaration from our example in more detail.

```rust,noplayground
#[macro_export]
macro_rules! sum_nums {
    ( $x:expr, $y:expr ) => { $x + $y }
}
```

Here, `( $x:expr, $y:expr )` is the pattern for what we expect as macro arguments. The syntax for pattern arguments is: `$argument_name : argument_type`.

`( $x:expr, $y:expr )` means we expect two arguments, each of which must be a valid Rust expression (the `expr` type stands for expression).

This type checking of arguments makes declarative macros convenient and safe. For instance, we can call this macro with any valid expressions:

```rust
sum_nums!(1 + 1, 2 + 2); // => 1 + 1 + 2 + 2

sum_nums!({ 1 + 1 }, { 2 + 2 }) // => { 1 + 1 } + { 2 + 2 }

sum_nums!(if 5 > 4 { 1 } else { -1 }, 9); // => if 5 > 4 { 1 } else { -1 } + 9
```

## Macro Argument Types

Besides expressions, macros can distinguish between a variety of Rust constructs. Below is a full list of valid argument types (fragment specifiers) for macros. You might not be familiar with many of these yet, so don't worry about memorizing them. The goal of this chapter isn't to make you a macro expert, but to give you enough understanding to use them comfortably.

| Fragment  |                         Matches With                                  | Can be followed by |
| --------- | --------------------------------------------------------------------- | ---------------- |
| `expr`    | A Rust expression: `2 + 2`, `"aaa"`, `x.len()`                        | `=>`, `;`        |
| `stmt`    | A statement (usually ends in a semicolon)                             | `=>`, `;`        |
| `ty`      | A data type: `String`, `Vec<u8>`, `(&str, bool)`                      | `=>`, `=`        |
| `path`    | a path: `crate::module`, `::std::sync::mpsc`                          | `=>`, `=`        |
| `pat`     | A pattern (destructuring): `_`, `Some(ref x)`                         | `=>`, `=`        |
| `item`    | An item: `struct Point {x: f64, y: f64}`, `mod mymod;`                | что угодно       |
| `block`   | A code block / scope:: `{ s+= "ok"; true }`                           | что угодно       |
| `meta`    | An attribute body: `inline`, `derive(Copy,Clone)`, `doc="3d models."` | что угодно       |
| `ident`   | An identifier: `std`, `Json`, `my_var`                                | что угодно       |
| `tt`      | A token tree: `;`, `>=`, `{}`, `[0 1 (+ 0 1)]`                        | что угодно       |
| `literal` | A literal: `5`, `5u32`, `1.0`, `"Hello"`                              |                  |
| `vis`     | Visibility qualifier: `pub`, `pub (crate)`                            |                  |

As you can see, thanks to the type system for arguments, Rust macros are much safer than those in C.

Furthermore, if a macro is used incorrectly, you will receive a meaningful compilation error for the macro call itself, rather than for the mangled code generated by the macro, which is a common headache in C.

## Variadic Arguments

Rust doesn't support functions with a variable number of arguments (variadic functions), but this limitation is compensated for by macros.

Let's look at a macro that takes an arbitrary number of numeric literals and constructs their sum:

```rust
#[macro_export]
macro_rules! sum_nums {
    () => { 0 };
    (  $first:literal $(, $rest:literal )* ) => {
        $first $( + $rest )*
    };
}

fn main() {
    let res = sum_nums!(1, 2, 3, 4, 5);
    println!("Sum is: {}", res); // Sum is: 15
}
```

This macro has two patterns (match arms).

The first pattern `() => { 0 }` is simple: it handles the case where no values are passed to the macro. In this instance, we simply return `0`.

The second pattern expects at least one argument, which is bound to the name `$first`. This can be followed by any number of comma-separated numbers, and this entire sequence is bound to `$( $rest )*`. Note that the comma itself is discarded as it isn't bound to an argument name.

The result of this template is the literal bound to `$first`, followed by all elements of the sequence bound to `$rest`, with a `+` sign added before each element.

Thus, the call `sum_nums!(1, 2, 3, 4, 5)` expands to `1 + 2 + 3 + 4 + 5`.

***

This macro can be written even more simply:

```rust
#[macro_export]
macro_rules! sum_nums {
    ( $( $rest:expr ),* ) => { 0 $( + $rest )* }
}
```

Here, we take advantage of the fact that adding zero to any number results in that same number. We bind all macro arguments to `$( $rest )*`, and in the body, we sum `0` with all the provided arguments.

```rust,noplayground
sum_nums!(1,);      // 0 + 1
sum_nums!(1, 2, 3); // 0 + 1 + 2 + 3
sum_nums!();        // 0
```

## Brackets

You may have noticed that we call our macro using parentheses: `sum_nums!(1, 2)`. Meanwhile, the `vec!` macro is often called using square brackets. What’s the difference?

In reality, both our macro and `vec!` can be called with any type of brackets:

```rust,noplayground
sum_nums!(1, 2);
sum_nums![1, 2];
sum_nums!{1, 2};
vec!(1, 2, 3);
vec![1, 2, 3];
vec!{1, 2, 3};
```

You should use whichever variant feels more expressive for the task.

The only technical difference is the requirement for a semicolon `;` after the call. If a macro is used to generate a function or a struct, you don't need a semicolon if you use curly braces `{}`.

```rust
// A macro that creates an empty function with a given name
#[macro_export]
macro_rules! make_empty_func {
    ($func_name:ident) => {
        fn $func_name() {}
    }
}

make_empty_func!(function_1); // Semicolon is required here
make_empty_func!{function_2}  // No semicolon needed

fn main() {
    function_1();
    function_2();
}
```



## The vec! Macro

Now that we've been introduced to declarative macros, it becomes clear why `vec![]` is a macro rather than a function: functions don't support a variable number of arguments.

The real implementation of `vec![]` is such that `vec![1, 2, 3]` expands to `<[_]>::into_vec(::alloc::boxed::box_new([1, 2, 3]))` (which we aren't quite ready to dissect yet). However, for educational purposes, let's write a simpler implementation—the classic "learning macro" `vec2!`.

Macro code:

```rust
#[macro_export]
macro_rules! vec2 {
    () => { Vec::new() };
    ( $( $x:expr),* ) => {
        {
            let mut _temp = Vec::new();
            $( _temp.push($x); )*
            _temp
        }
    }
}
```

Macro invocation comparison:

<table class="two-side">
<tr>
<td width="45%">

This invocation code

```rust,noplayground
fn main() {
    let v = vec2![1,2,3];
    println!("{v:?}");
}
```

</td>
<td width="55%">
expands into

```rust
fn main() {
    let v = {
        let mut _temp = Vec::new();
        _temp.push(1);
        _temp.push(2);
        _temp.push(3);
        _temp
    };
    println!("{v:?}");
}
```

</td>
</tr>
</table>
